docker-compose up
我已经将docker封装了，运行这个代码可以启用环境，前提是你有docker
【要把kafka配置到本地localhost【上网找教程就好】】
## 定义问题
开发一个系统来模拟从物流方接收货物，然后将货物放到仓库存储的过程。
client我理解为一个发送器拿在员工手里，api则是系统，他们用kfk相连
假设只有一个物流处为初始点，不处理如果有多个仓库仓库转运的问题，假设一批货物就是同一种货物，一个格子可以放100个货物
## 仓库状态设置
**need**:
- **warehouse**: 数组，可以有多个仓库（初始1个）
- 属性：1.id 2.可用的格子(json) 3.三维（"dimensions": {"x": 5, "y": 5, "z": 2},）4.距离物流点的距离
- **vehicles**: 数组，可以有多个车辆（初始2个）
- 属性：1.id 2.类型(叉车/传送带) 3.速度 4.状态（空闲/使用） 6.位置（仓库/物流点/未知）
- **lift**: 数组，可以有多个升降机（初始2个）【每一个仓库必须有一个lift】
- 属性：1.id 2.速度(假设在平面上移动和他升降是一个速度) 4.状态(空闲/使用) 6.位置（仓库id）
- **inbound**: 数组，到达货物
- 属性：1.id 2.货物单号 3，货物详情（直接给货物id）4.货物数量 4.文件信息（必要的文件，如发票、提单和保修证明//直接给一个json存储）
- 6.货物状态（已卸货/未卸货/已入库）7.货物位置(物流处/仓库id) 6.创建时间
- **inventory**: 数组，货物表
- 属性：1.id 2.货物单号 3，货物详情（直接给货物id）4.货物数量 4.文件信息（必要的文件，如发票、提单和保修证明//直接给一个json存储）
- 6.货物状态（入库/准备出库）7.货物位置(仓库id) 6.货物仓库位置（用x，y，z表示）【可以有多个，一个（x,y,z）代表一个格子，可以放100个物品】7.创建时间
- **outbound**: 数组，货物表
- 属性：1.id 2.货物单号 3，货物详情（直接给货物id）4.货物数量 4.文件信息（必要的文件，如发票、提单和保修证明//直接给一个json存储）
- 6.货物状态（出库中/已出库）7.创建时间
通过设计和描述你的仓库状态JSON，我们可以有效地管理和跟踪系统的运行状态。以下是你提到的JSON结构的一个示例：

```json
{
  "warehouse": [
    {
      "id": "WH001",
      "availableSlots": 500,
      "dimensions": {"x": 5, "y": 5, "z": 2},
      "distanceFromLogisticPoint": 10
    }
  ],
  "vehicles": [
    {
      "id": "V001",
      "type": "forklift",
      "speed": 2,
      "status": "idle",
      "location": "warehouse"
    },
    {
      "id": "V002",
      "type": "conveyor_belt",
      "speed": 3,
      "status": "in_use",
      "location": "logistic_point"
    }
  ],
  "lift": [
    {
      "id": "L001",
      "speed": 1,
      "status": "idle",
      "location": "WH001"
    }
  ],
  "inbound": [
    {
      "id": "IN001",
      "shipmentId": "SH12345",
      "itemId": "IT001",
      "quantity": 100,
      "documents": {
        "invoice": "INV12345",
        "billOfLading": "BL12345",
        "warranty": "WT12345"
      },
      "status": "arrived",
      "location": "logistic_point",
      "creationTime": "2024-06-07T10:00:00Z"
    }
  ],
  "inventory": [
    {
      "id": "IV001",
      "shipmentId": "SH12345",
      "itemId": "IT001",
      "quantity": 100,
      "documents": {
        "invoice": "INV12345",
        "billOfLading": "BL12345",
        "warranty": "WT12345"
      },
      "status": "stored",
      "location": "WH001",
      "warehouseLocation": {"x": 2, "y": 3, "z": 1},
      "creationTime": "2024-06-07T10:30:00Z"
    }
  ],
  "outbound": [
    {
      "id": "OUT001",
      "orderId": "ORD67890",
      "itemId": "IT001",
      "quantity": 100,
      "documents": {
        "invoice": "INV67890",
        "billOfLading": "BL67890",
        "warranty": "WT67890"
      },
      "status": "loading",
      "creationTime": "2024-06-07T11:00:00Z"
    }
  ]
}
```

### 事件驱动系统设计：从货物到达到仓库存储

根据你的描述，我们需要一个详细的设计来模拟从物流方接收货物，然后将货物放到仓库存储的整个过程。下面是详细的事件描述、生产者和消费者的行为，以及合理的传输数据格式。

### 1. 主要事件（Events）

1. **GoodsArrived**：货物到达物流点。
   - **生产者**：物流系统或卸货请求发起者。
   - **消费者**：卸货服务。
   - **动作**：触发卸货流程，分配仓库ID。

2. **UnloadingStarted**：开始卸货。
   - **生产者**：卸货服务。
   - **消费者**：状态管理器、设备分配服务。
   - **动作**：记录开始卸货的时间，分配设备。

3. **UnloadingCompleted**：卸货完成。
   - **生产者**：卸货服务。
   - **消费者**：存储服务。
   - **动作**：记录卸货完成的时间，触发入库流程。

4. **InspectionCompleted**：检查和文档处理完成。
   - **生产者**：检查和文档处理服务。
   - **消费者**：仓库存储服务。
   - **动作**：触发将货物移入仓库内指定位置的过程。

5. **StorageLocationAllocated**：分配仓库存储位置。
   - **生产者**：仓库存储服务。
   - **消费者**：存储服务。
   - **动作**：触发将货物从物流点运输到仓库的过程。

6. **StorageStarted**：入库开始。
   - **生产者**：仓库内的存储服务。
   - **消费者**：升降机控制服务。
   - **动作**：分配升降机，准备将货物从地面位置移动到最终存储位置。

7. **StorageCompleted**：入库结束。
   - **生产者**：升降机控制服务。
   - **消费者**：库存管理服务。
   - **动作**：更新库存，记录货物最终存储位置。

8. **OrderReceived**：接收到出库订单。
   - **生产者**：订单管理系统。
   - **消费者**：出库处理服务。
   - **动作**：触发货物出库流程。

9. **GoodsLoadingStarted**：出库开始。
   - **生产者**：出库处理服务。
   - **消费者**：状态管理器。
   - **动作**：更新货物状态，记录装载开始时间。

10. **GoodsShipped**：出库结束。
   - **生产者**：出库处理服务。
   - **消费者**：状态管理器、物流系统。
   - **动作**：更新货物状态，通知物流系统。

### 2. 事件的生产者和消费者行为

以下是每个事件的生产者和消费者如何互动的详细描述：

#### GoodsArrived

- **生产者**：物流系统发布此事件。
- **消费者**：卸货服务监听此事件，触发卸货流程，分配仓库ID。

```json
{
   "shipmentId": "SH12345",
   "warehouseId": "WH001",
   "itemId": "IT002",
   "quantity": 100,
   "arrivalTime": "2024-06-07T10:00:00Z"
}

```

**行为**：
- 生产者发布`GoodsArrived`事件，包含货物详细信息和仓库ID。
- 消费者（卸货服务）接收到此事件，触发卸货流程。

#### UnloadingStarted

- **生产者**：卸货服务发布此事件。
- **消费者**：状态管理器、设备分配服务监听此事件，分配适当的卸货设备。

```json
{
   "shipmentId": "SH12345",
   "warehouseId": "WH001",
   "vehicleId":"V001",
   "startTime": "2024-06-07T10:05:00Z"
}
```

**行为**：
- 生产者（卸货服务）在开始卸货时发布`UnloadingStarted`事件。
- 消费者（状态管理器、设备分配服务）接收到事件后，记录状态并分配卸货设备。

#### UnloadingCompleted

- **生产者**：卸货服务发布此事件。
- **消费者**：存储服务监听此事件，开始入库流程。

```json
{
  "shipmentId": "SH12345",
  "warehouseId": "WH001",
  "vehicleId":"V001",
  "completionTime": "2024-06-07T10:15:00Z"
}
```
**行为**：
- 生产者（卸货服务）在完成卸货时发布`UnloadingCompleted`事件。
- 消费者（存储服务）接收到事件后，触发入库流程。
------------------------------
入库流程
#### InspectionCompleted

- **生产者**：检查和文档处理服务发布此事件。
- **消费者**：仓库存储服务监听此事件，准备货物入库。
- 给数据库里的加上documents就好了
- 然后吧数据放到新表inventory里
```json
{
  "id": "IN001",
  "inspectionTime": "2024-06-07T10:25:00Z",
  "documents": {
    "invoice": "INV12345",
    "billOfLading": "BL12345",
    "warranty": "WT12345"
  }
}
```

**行为**：
- 生产者（检查和文档处理服务）在完成货物检查后发布`InspectionCompleted`事件。
- 消费者（仓库存储服务）接收到事件后，准备货物的入库。

#### StorageLocationAllocated

- **生产者**：仓库存储服务发布此事件。
- **消费者**：存储服务监听此事件，准备运输货物到仓库。
- 因为处理位置比较复杂，所以位置和数量是分开考虑的然后从上到下放比如（5，5，2）（5，0，2）（0，0，2）-（5，5，1）
- 处理完之后会自动给他分配格子，检查如果格子变成000，则容量也变成0
```json
{
  "status" :"succes"
           
}
```
**行为**：
- 生产者（仓库存储服务）在分配仓库位置时发布`StorageLocationAllocated`事件。
- 消费者（存储服务）接收到事件后，准备运输货物到仓库的具体位置。

#### StorageStarted

- **生产者**：仓库内的存储服务发布此事件。
- **消费者**：升降机控制服务监听此事件，分配升降机以开始入库过程。

```json
{
  "id": "IN001",
  "startTime": "2024-06-07T10:35:00Z"
}
```

**行为**：
- 生产者（仓库内的存储服务）在开始货物入库时发布`StorageStarted`事件。
- 消费者（升降机控制服务）接收到事件后，分配升降机以将货物移动到最终存储位置。

#### StorageCompleted

- **生产者**：升降机控制服务发布此事件。
- **消费者**：库存管理服务监听此事件，更新库存信息。

```json
{
  "shipmentId": "SH12345",
  "warehouseId": "WH001",
  "completionTime": "2024-06-07T10:45:00Z",
  "storageLocation": {"x": 2, "y": 3, "z": 1}
}
```

**行为**：
- 生产者（升降机控制服务）在完成货物入库时发布`StorageCompleted`事件。
- 消费者（库存管理服务）接收到事件后，更新库存信息并记录货物的最终存储位置。
-------------------------------------
#### OrderReceived

- **生产者**：订单管理系统发布此事件。
- **消费者**：出库处理服务监听此事件，触发货物出库流程。

```json
{
  "orderId": "ORD67890", 
   "itemId": "IT001",
   "quantity": 20
}
```
需要消费者收到信号后，检查有没有足够的库存，并检查有没有足够的lift车，有就返回好，把lift设置为在使用，并返回lift需要的时间和车号,并再outbound.json表里生成对应的出库信息，然后把库存表里的物品数量减掉
**行为**：
- 生产者（订单管理系统）在接收到出库订单时发布`OrderReceived`事件。
- 消费者（出库处理服务）接收到事件后，准备货物的出库流程。

#### GoodsShipped

- **生产者**：出库处理服务发布此事件。
- **消费者**：状态管理器、物流系统监听此事件，更新货物状态并通知物流系统。

```json
{
  "orderId": "ORD67890",
  "warehouseId": "WH001"
}
```

**行为**：
- 生产者（出库处理服务）在货物准备运输到目的地时发布`GoodsShipped`事件。
- 消费者（状态管理器、物流系统）接收到事件后，更新货物状态并通知物流系统。

### 3. 使用Kafka进行事件传输

Kafka是事件驱动系统的核心，用于高效传输和处理事件。以下是Kafka的使用建议：

- **主题（Topics）**：
   - 为每个事件类型创建一个单独的主题，例如`goods-arrived`、`unloading-started`等。
   - 使用分区（Partitions）来增加吞吐量和并行处理能力。

- **生产者（Producers）**：
   - 生产者根据事件类型将消息发送到相应的Kafka主题。

- **消费者（Consumers）**：
   - 消费者订阅相关的Kafka主题，监听并处理事件。
